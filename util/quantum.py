import numpy as np
from math import sin, cos
from lambeq.backend.quantum import Box, qubit
from .auxillary import truncate, log_mat, prt_trace, prt_transpose, trace_norm, sep_state, wedge_prod, lr_kron

def bell_viol(state: np.ndarray, obs: np.ndarray) -> float:
    # Calculates the bell violation of a given state and some observables
    expectations = [(np.conjugate(state) @ (obs[ops] @ state)) for ops in list(obs.keys())]
    return max([sum(expectations) - 2*exp for exp in expectations])

def vn_ent(dmat: np.ndarray, fast=True) -> float:
    # Compute von Neumann entropy of a, pontetially pure, ensemble  described by the density matrix
    if fast:
        ent =  -np.trace(dmat @ log_mat(dmat))
    else:
        evals = np.linalg.eigvals(dmat)
        evals = evals[np.abs(evals) > 1e-12]
        ent = -np.sum(evals * np.log2(evals))
    ent = ent.round(12)
    return abs(ent)

def ent_ent(dense_mat: np.ndarray) -> float:
    # Compute entropy of entanglement for a bipartide system, due to symmetry it can be done w.r.t. either subsystem
    rho_a, rho_b = prt_trace(dense_mat)
    return calc_vne(rho_a)

def rel_ent(mat1: np.ndarray, mat2: np.ndarray) -> float:
    # Compute relative entropy given two ensembles 
    return np.trace(mat1 @ (log_mat(mat1) - log_mat(mat2)))

def neg(dmat: np.ndarray, fast=True) -> float:
    # Compute negativity of an ensemble
    rho_tra = prt_transpose(dense_mat, False)
    if fast:
        evals = np.linalg.eigvalsh(rho_tra)
        evals[evals > 0] = 0
        return abs(sum(evals))
    else:
        return abs((trace_norm(rho_tra) - 1)/2)

def log_neg(dense_mat: np.ndarray, fast=True) -> float:
    # Compute logarithmic negativity of an ensemble
    if fast:
        return np.log2(2*calc_neg(dense_mat) + 1)
    return np.log2(abs(trace_norm(partial_transpose(dense_mat, False))))

def state2dense(state: np.ndarray, tol=1e-12) -> np.ndarray:
    # Convert a state into its pure desnity matrix representation
    dmat = np.outer(state, np.conjugate(state))
    dmat = truncate(dmat, tol)
    return dmat

def get_bitstr(psi: [int], bit_str=True):
    psi_dim = len(psi)
    decomp_psi = []

    while psi_dim > 1:
        psi_dim = int(psi_dim/2)
        bases = np.split(psi, psi_dim) 
        psi = np.array([sum(base) for base in bases])
        decomp_psi.append(bases[np.argmax(psi)])

    if bit_str:
        return np.array([(0 if np.array_equal(e,[1,0]) else 1) for e in reversed(decomp_psi)])
    else: 
        return np.array(list(reversed(decomp_psi)))

def remove_q(psi: [float], j, b=-1): 
    split_0 = []
    split_1 = []
    
    psi_decomp = sep_state(psi) 
    for basis_state in psi_decomp: 
        amplitude = sum(basis_state)
        if amplitude == 0: 
            continue
        basis_state = basis_state/amplitude
        bit_str = get_bitstr(basis_state, False)
        target_qbit = bit_str[j]
        bit_str = np.delete(bit_str, j, 0)
        new_state = amplitude * lr_kron(bit_str)
        if np.array_equal(target_qbit,[1,0]): 
            split_0.append(new_state)
        else: 
            split_1.append(new_state)
        

    if b == 0: 
        return np.array(split_0).sum(axis=0)
    elif b == 1: 
        return np.array(split_1).sum(axis=0)
    else: 
        return (np.array(split_0).sum(axis=0), np.array(split_1).sum(axis=0))

def mw_measure(psi: [float]): 
    qn = int(np.log2(len(psi)))
    res = 0
    for j in range(qn): 
        res += wedge_prod(*remove_q(psi, j))
    return res*4/qn

def gen_rot(theta:float=0, phi:float=0) -> np.ndarray:
    # Generates a rotation on the Bloch sphere
    ry = np.array([[cos(theta/2), -sin(theta/2)], [sin(theta/2), cos(theta/2)]])
    rz = np.array([[np.e**(-1j*phi/2),0], [0, np.e**(1j*phi/2)]])
    obs = ry @ rz
    return truncate(obs, 1e-9)

def gen_basis(theta:float=0, phi:float=0) -> (np.ndarray, np.ndarray):
    # Generates an orthonormal pair of basis rotations spanning the whole bloch sphere
    return (rot(theta, phi), rot(np.pi - theta, np.pi + phi))

def gen_obs(name="O", data=None, theta=0, phi=0):
    if type(data) != np.ndarray:
        data = gen_rot(theta, phi)
    return Box(name=name, dom=qubit, cod=qubit, data=data) 

def rand_state(nq:int=1) -> np.ndarray:
    # Generates a random n-qubit state
    state = np.zeros((2**nq), dtype=np.complex128)
    state.real = np.random.uniform(0,1,(2**nq))
    state.imag = np.random.uniform(0,1,(2**nq))
    state = np.sqrt(state / sum(abs(state)))
    return state

def gen_contexts(n=10000):
    # Generates random contexts based on random observables generated by Bloch sphere rotations
    contexts = []
    n = round(n**0.5)
    for phi1 in np.linspace(0, 2*np.pi, n):
        for phi2 in np.linspace(0, 2*np.pi, n):
            onb1 = gen_rot(np.pi/2, phi1)
            onb2 = gen_rot(np.pi/2, phi2)
            context = {'ab': np.kron(onb1, onb1), 
                       'aB': np.kron(onb1, onb2), 
                       'Ab': np.kron(onb2, onb1), 
                       'AB': np.kron(onb2, onb2)}
            contexts.append(context)
    return np.array(contexts)

def gen_bell(n, rand=False):
    # Generates uniform or random maximally entangled states
    states = []
    n = round(n**0.5)
    if rand:
        theta_arr = np.random.uniform(0, np.pi, n)
        phi_arr = np.random.uniform(0, np.pi*2, n)
    else:
        theta_arr = np.linspace(0, np.pi, n)
        phi_arr = np.linspace(0, np.pi*2, n)

    for theta in theta_arr:
        for phi in phi_arr:
            state = np.array([np.cos(theta/2), 0, 0, np.sin(theta/2)*(np.cos(phi)+1j*np.sin(phi))], dtype=np.complex128)
            states.append(state)
    return (theta_arr, phi_arr, np.array(states, dtype=np.complex128))
